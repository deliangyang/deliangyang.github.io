
上一篇提到Python中出现了非真(True)非假(False)的情况。既不是True也不是False，是不是有点困惑，下面就让我来分析一下。

抽象意义上确实只有真或者假，但是在Python中（其它弱类型语言也是同样的一个原理），在弱类型语言中，True或者False是两个分类，分别管理了一类型的值。比如0，空字符串，空列表，空字典等等，这些值都是假，所以都属于False类型，而其它的值都是真，所以都属于True类型。这里先开个头，后续会详细介绍。

回顾一下指令`POP_JUMP_IF_FALSE`，如果栈顶元素为假，则跳转到指定的位置，否则继续执行下一条指令。
```c
    case TARGET(POP_JUMP_IF_FALSE): {       // pop TOS and jump if false
        PREDICTED(POP_JUMP_IF_FALSE);
        PyObject *cond = POP();
        int err;
        if (Py_IsTrue(cond)) {      // 如果条件为真，则不跳转
            Py_DECREF(cond);
            DISPATCH();
        }
        if (Py_IsFalse(cond)) {     // 如果条件为假，则跳转到指定位置
            Py_DECREF(cond);
            JUMPTO(oparg);
            CHECK_EVAL_BREAKER();
            DISPATCH();
        }
        err = PyObject_IsTrue(cond);
        Py_DECREF(cond);
        if (err > 0)
            ;
        else if (err == 0) {
            JUMPTO(oparg);              // 跳转到指定位置, oparg是指定位置的偏移量
            CHECK_EVAL_BREAKER();
        }
        else
            goto error;
        DISPATCH();
    }
```
`POP_JUMP_IF_TRUE`指令代码如下，如果栈顶元素为真，则跳转到指定的位置，否则继续执行下一条指令。

```c
    case TARGET(POP_JUMP_IF_TRUE): {        // pop TOS and jump if true
        PREDICTED(POP_JUMP_IF_TRUE);
        PyObject *cond = POP();
        int err;
        if (Py_IsFalse(cond)) {             // 如果条件为假，则不跳转
            Py_DECREF(cond);
            DISPATCH();
        }
        if (Py_IsTrue(cond)) {              // 如果条件为真，则跳转到指定位置
            Py_DECREF(cond);
            JUMPTO(oparg);
            CHECK_EVAL_BREAKER();
            DISPATCH();
        }
        err = PyObject_IsTrue(cond);
        Py_DECREF(cond);
        if (err > 0) {
            JUMPTO(oparg);                  // 如果条件为真，则跳转到指定位置
            CHECK_EVAL_BREAKER();
        }
        else if (err == 0)
            ;
        else
            goto error;
        DISPATCH();
    }
```

`POP_JUMP_IF_FALSE`和`POP_JUMP_IF_TRUE`代码基本一致，只是判断条件的顺序不同，`POP_JUMP_IF_FALSE`先判断条件是否为真，如果为真则不跳转，如果为假则跳转到指定位置；`POP_JUMP_IF_TRUE`先判断条件是否为假，如果为假则不跳转，如果为真则跳转到指定位置。

起到关键作用的是`Py_IsTrue`和`PyObject_IsTrue`。接下来就分析一下这两块带代码的实现

### Py_IsTrue 是宏定义

`Py_False`和`Py_True`是全局定义的值，它们分别是`_Py_FalseStruct`和`_Py_TrueStruct`结构的内存地址，程序启动之后它们的内存地址是不变的。`Py_Is(x, y)` 其实就是比较两个对象的内存地址是否相等，如果相等则返回1，否则返回0。

```c
/* Use these macros */
#define Py_False ((PyObject *) &_Py_FalseStruct)
#define Py_True ((PyObject *) &_Py_TrueStruct)

// Test if an object is the True singleton, the same as "x is True" in Python.
PyAPI_FUNC(int) Py_IsTrue(PyObject *x);
#define Py_IsTrue(x) Py_Is((x), Py_True)

// Test if an object is the False singleton, the same as "x is False" in Python.
PyAPI_FUNC(int) Py_IsFalse(PyObject *x);
#define Py_IsFalse(x) Py_Is((x), Py_False)

// Test if the 'x' object is the 'y' object, the same as "x is y" in Python.
PyAPI_FUNC(int) Py_Is(PyObject *x, PyObject *y);
#define Py_Is(x, y) ((x) == (y))

/* The objects representing bool values False and True */

struct _longobject _Py_FalseStruct = {
    PyVarObject_HEAD_INIT(&PyBool_Type, 0)
    { 0 }
};

struct _longobject _Py_TrueStruct = {
    PyVarObject_HEAD_INIT(&PyBool_Type, 1)
    { 1 }
};

```


### PyObject_IsTrue 是一个函数

`PyObject_IsTrue`的参数是一个PyObject对象，返回值是一个int类型的值，1为真，0为假，代码如下。

可以看出v有可能是`Py_True`、`Py_False`、`Py_None`、数字类型、映射类型、序列类型的长度，长度等于0为假，其它情况都是真。

```c
int
PyObject_IsTrue(PyObject *v)
{
    Py_ssize_t res;
    if (v == Py_True)           // 如果v是Py_True，则返回1
        return 1;
    if (v == Py_False)          // 如果v是Py_False，则返回0
        return 0;
    if (v == Py_None)           // 如果v是Py_None，则返回0
        return 0;
    else if (Py_TYPE(v)->tp_as_number != NULL &&
             Py_TYPE(v)->tp_as_number->nb_bool != NULL)     // 如果v是一个数字类型，则调用nb_bool函数
        res = (*Py_TYPE(v)->tp_as_number->nb_bool)(v);
    else if (Py_TYPE(v)->tp_as_mapping != NULL &&
             Py_TYPE(v)->tp_as_mapping->mp_length != NULL)  // 如果v是一个映射类型，则调用mp_length函数
        res = (*Py_TYPE(v)->tp_as_mapping->mp_length)(v);
    else if (Py_TYPE(v)->tp_as_sequence != NULL &&
             Py_TYPE(v)->tp_as_sequence->sq_length != NULL) // 如果v是一个序列类型，则调用sq_length函数
        res = (*Py_TYPE(v)->tp_as_sequence->sq_length)(v);
    else
        return 1;
    /* if it is negative, it should be either -1 or -2 */
    return (res > 0) ? 1 : Py_SAFE_DOWNCAST(res, Py_ssize_t, int);
}
```

## 全等和不全等

从上面的代码实现你是不是对True和False的判断有了更深的理解呢？是不是可以联想到其它弱类型语言中True和False的时间呢？比如PHP中空串，空数组，0，null等都是假。

到这里有产生了新的困惑。那有没有真就是真，假就是假，即全等呢？例如PHP中的`===`全等。答案是有的，Python中的`is`就是全等，`is not`就是不全等。

```python
>>> a = True
>>> a is True
True
>>> a = 1
>>> a is True
False
>>>
```

用dis模块，输出一下`is`的字节码，结果如下。
```bash
a = True
a is True

  1           0 LOAD_CONST               0 (True)
              2 STORE_NAME               0 (a)

  2           4 LOAD_NAME                0 (a)
              6 LOAD_CONST               0 (True)
              8 IS_OP                    0
             10 POP_TOP
             12 LOAD_CONST               1 (None)
             14 RETURN_VALUE
```

`IS_OP`自己码的实现如下。

```c
    case TARGET(IS_OP): {           // check object identity
        PyObject *right = POP();    // 弹出栈顶的对象
        PyObject *left = TOP();     // 取出栈顶的对象
        int res = Py_Is(left, right) ^ oparg;   // 判断两个对象的内存地址是否相等
        PyObject *b = res ? Py_True : Py_False; // 如果相等则返回Py_True，否则返回Py_False
        Py_INCREF(b);
        SET_TOP(b);                 // 将结果压入栈顶
        Py_DECREF(left);            // 释放left和right的引用
        Py_DECREF(right);           // 释放left和right的引用
        PREDICT(POP_JUMP_IF_FALSE); // 预测下一条指令，是否是POP_JUMP_IF_FALSE
        PREDICT(POP_JUMP_IF_TRUE);  // 预测下一条指令，是否是POP_JUMP_IF_TRUE
        DISPATCH();
    }
```

## 总结

1. Python中的True和False是单例模式，即全局只有一个实例。
2. 弱类型语言True和False的判断需要慎重，is和is not是全等和不全等，==和!=是值相等和值不相等。
3. 举一反三，可以联想到其它弱类型语言的实现原理基本相似，只是细节上有所不同。特别是解释型编程语言，设计者都会设计统一的基础数据结构，通过类型标记来区分不同的数据类型，扩展更加高级的数据结构。Python内核的基础数据结构是PyObject。