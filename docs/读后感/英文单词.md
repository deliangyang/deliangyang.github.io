
- REPL
  - read-evaluate-print-loop
- RPPL
  - read-parse-print-loop
- for now
  - currently
- in place
  - 到位，准备就绪
- treated
  - 处理过
- unintended
  - 非预期，无意的
- As I said, this is where we decide how the language works.
- seem like
- make sense
  - 有意义，有道理
- truthy
  - 诚实
- of course
- instead of ... or ...
  - 而不是
- solely
  - 仅仅、唯独、完全
- knock yourself out
- strictly speaking
- we added two new and concise functions
  - 简约、要言不烦、精炼


- Supporting strings in our lexer
  - The first thing we have to do is add support for string literals to our lexer
  - That's not too hard, right?
  - It's time to teach the parser how to do the same.
  - Of course, string literals are exprestions and not statements.
  - With the definition we can write a small test case that make sure the parse knows how to handle token.STRING tokens and outputs *ast.StringLiterals
  - So now len is found when looking up the len identifier, calling it doesn't work ye.
  - That means that calling len works though
  - As we saw before.
  - Just to make sure that the parsing of expressions really works the test input contains two different infix operator expressions, even though integer or boolean literals would be enough.
  - off-by-one 逐一
  - one by one 逐个
  - Some languages produce an error in such a case and some return a null value.
  - I choose to return NULL.
  - As expected the tests are failing. And not noly that, they're blowing up.
  - So how do we fix this and evaluate index expressions?
  - As we've seen, the left operand of the index operator can be any expression and the index itself can be any expression.
  - Otherwise
  - Okay, now take a deep breath, relax and take a loot at this: