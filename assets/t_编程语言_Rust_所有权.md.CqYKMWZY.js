import{_ as i,c as a,a3 as n,o as t}from"./chunks/framework.BOyF8YV7.js";const c=JSON.parse('{"title":"Rust 所有权系统详解：内存管理、借用与数据竞争","description":"深入了解 Rust 的所有权系统，包括所有权规则、String 类型、引用和借用、可变引用以及如何避免数据竞争。学习如何编写安全高效的 Rust 代码。","frontmatter":{"head":[["link",{"rel":"canonical","href":"https://blog.ranchulin.com/t/编程语言/Rust/所有权.html"}],["meta",{"property":"og:title","title":"Rust 所有权系统详解：内存管理、借用与数据竞争"}],["meta",{"property":"og:url","content":"https://blog.ranchulin.com/t/编程语言/Rust/所有权.html"}],["meta",{"name":"keywords","content":"Rust,所有权,内存管理,垃圾回收,借用,引用,可变引用,栈,堆,String,clone,数据竞争,作用域"}]]},"headers":[],"relativePath":"t/编程语言/Rust/所有权.md","filePath":"t/编程语言/Rust/所有权.md","lastUpdated":1736299776000}'),l={name:"t/编程语言/Rust/所有权.md"};function e(p,s,h,r,k,d){return t(),a("div",null,s[0]||(s[0]=[n(`<h3 id="rust-所有权" tabindex="-1">Rust 所有权 <a class="header-anchor" href="#rust-所有权" aria-label="Permalink to &quot;Rust 所有权&quot;">​</a></h3><blockquote><p>所有权（系统）是 Rust 最独特的功能，可以使得 Rust 无需垃圾回收就可以保障内存的安全。因此，理解 Rust 中的所有权如何工作是十分的重要的。所欲全的功能：借用，slice，以及 Rust 如何在内存中布局数据的。<br> 所有运行的程序都必须管理其使用计算机内存的方式，一些语言中具有垃圾回收机制，在程序运行时不断地寻找不再使用的内存；还有一些语言程序员必须亲自分配和释放内存，例如 C 语言。Rust 则选择了第三种方式，通过所有权系统管理内存，编译器在编译的时候会根据一些列的规则进行检查。在运行的时候所有权系统的任何功能不会减慢程序。<br> 了解了 Rust 的所有权系统的规则，我们就会很自然地写出安全高效的代码。</p></blockquote><h4 id="所有权规则" tabindex="-1">所有权规则： <a class="header-anchor" href="#所有权规则" aria-label="Permalink to &quot;所有权规则：&quot;">​</a></h4><ol><li>Rust 中的内一个值都有一个被称为其所有者的变量。</li><li>值有且只有一个所有者。</li><li>当所有者（变量）离开作用域，这个值将被丢弃。</li></ol><h3 id="string-类型" tabindex="-1">String 类型 <a class="header-anchor" href="#string-类型" aria-label="Permalink to &quot;String 类型&quot;">​</a></h3><ul><li>string.clone</li><li>String ptr,len, capacity</li><li>为什么整数类型不需要 clone 呢？ <ul><li>因为像整数类型在编译时一直大小的类型被整个存储在栈上，所以其拷贝其实际的值是最快的，也没有导致 x 失效。</li></ul></li></ul><div class="language-rust vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;x = {}, y = {}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, x, y);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="引用和借用" tabindex="-1">引用和借用 <a class="header-anchor" href="#引用和借用" aria-label="Permalink to &quot;引用和借用&quot;">​</a></h3><blockquote><p><code>&amp;</code>符号表示引用，它们允许你使用值但不获得其所有权。解引用<code>*</code>。我们将获取引用作为函数 参数称为<code>借用</code>(borrowing)。就像现实生活中一样，如果一个人拥有某样东西，你可以从他那里借来，当你使用完毕之后，你必须还回去。如果你需要尝试修改借用的变量？那么这个值必须是允许修改的可变引用。<code>&amp;mut s</code>。</p></blockquote><h4 id="限制允许可变性" tabindex="-1">限制允许可变性 <a class="header-anchor" href="#限制允许可变性" aria-label="Permalink to &quot;限制允许可变性&quot;">​</a></h4><div class="language-rust vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> mut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;mut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;mut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;{}, {}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, r1, r2);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这是一种受限制的方式允许，这种方式的好处是避免数据竞争，数据竞争类似于竞争条件，可以由三个行为造成：</p><ol><li>两个或者更多的指针同时访问同一个数据。</li><li>至少有一个指针被用来写入数据。</li><li>没有同步数据访问的机制。</li></ol><p><code>{}</code>大括号可以创建新的作用域，这样允许拥有多个可变引用，但是不能同时引用。</p>`,14)]))}const u=i(l,[["render",e]]);export{c as __pageData,u as default};
