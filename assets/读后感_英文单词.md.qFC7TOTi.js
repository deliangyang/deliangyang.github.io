import{_ as i,c as t,a3 as l,o}from"./chunks/framework.BOyF8YV7.js";const c=JSON.parse('{"title":"Implementing Expression Parsing with Top Down Operator Precedence in a Monkey Compiler","description":"This article details the implementation of expression parsing in a compiler for the Monkey programming language, focusing on operator precedence using a Top Down Operator Precedence approach.  It covers topics such as handling string literals,  AST representation,  infix and prefix operators, and resolving ambiguities in index expressions. The author also discusses the challenges of explaining algorithms and their implementation effectively.","frontmatter":{"head":[["link",{"rel":"canonical","href":"https://blog.ranchulin.com/读后感/英文单词.html"}],["meta",{"property":"og:title","title":"Implementing Expression Parsing with Top Down Operator Precedence in a Monkey Compiler"}],["meta",{"property":"og:url","content":"https://blog.ranchulin.com/读后感/英文单词.html"}],["meta",{"name":"keywords","content":"REPL,read-evaluate-print-loop,RPPL,read-parse-print-loop,parser,lexer,AST,abstract syntax tree,expression parsing,operator precedence,Top Down Operator Precedence,infix operators,prefix operators,string literals,token,grammar rules,programming language,monkey programming language,implementation,algorithm,terminology,integer literal,boolean literal,index expression,null value,parentheses"}]]},"headers":[],"relativePath":"读后感/英文单词.md","filePath":"读后感/英文单词.md","lastUpdated":1736299776000}'),n={name:"读后感/英文单词.md"};function s(r,e,a,p,h,u){return o(),t("div",null,e[0]||(e[0]=[l('<ul><li><p>REPL</p><ul><li>read-evaluate-print-loop</li></ul></li><li><p>RPPL</p><ul><li>read-parse-print-loop</li></ul></li><li><p>for now</p><ul><li>currently</li></ul></li><li><p>in place</p><ul><li>到位，准备就绪</li></ul></li><li><p>treated</p><ul><li>处理过</li></ul></li><li><p>unintended</p><ul><li>非预期，无意的</li></ul></li><li><p>As I said, this is where we decide how the language works.</p></li><li><p>seem like</p></li><li><p>make sense</p><ul><li>有意义，有道理</li></ul></li><li><p>truthy</p><ul><li>诚实</li></ul></li><li><p>of course</p></li><li><p>instead of ... or ...</p><ul><li>而不是</li></ul></li><li><p>solely</p><ul><li>仅仅、唯独、完全</li></ul></li><li><p>knock yourself out</p></li><li><p>strictly speaking</p></li><li><p>we added two new and concise functions</p><ul><li>简约、要言不烦、精炼</li></ul></li><li><p>Supporting strings in our lexer</p><ul><li>The first thing we have to do is add support for string literals to our lexer</li><li>That&#39;s not too hard, right?</li><li>It&#39;s time to teach the parser how to do the same.</li><li>Of course, string literals are exprestions and not statements.</li><li>With the definition we can write a small test case that make sure the parse knows how to handle token.STRING tokens and outputs *ast.StringLiterals</li><li>So now len is found when looking up the len identifier, calling it doesn&#39;t work ye.</li><li>That means that calling len works though</li><li>As we saw before.</li><li>Just to make sure that the parsing of expressions really works the test input contains two different infix operator expressions, even though integer or boolean literals would be enough.</li><li>off-by-one 逐一</li><li>one by one 逐个</li><li>Some languages produce an error in such a case and some return a null value.</li><li>I choose to return NULL.</li><li>As expected the tests are failing. And not noly that, they&#39;re blowing up.</li><li>So how do we fix this and evaluate index expressions?</li><li>As we&#39;ve seen, the left operand of the index operator can be any expression and the index itself can be any expression.</li><li>Otherwise</li><li>Okay, now take a deep breath, relax and take a loot at this:</li></ul></li><li><p>flesh out, flesh means body, 充实，开掘</p></li><li><p>represent - 重现？代表</p><ul><li>present - 目前，现在</li></ul></li><li><p>Personally, I think that parsing expressions is the most interseting part of writing a parser.</p></li><li><p>As we just saw, parsing statements is relatively straightforward.</p></li><li><p>What we want here is an AST that represents the expression like this:</p><ul><li>What we want here <ul><li>is an AST <ul><li>that represents the expression like this? <ul><li>that is an AST</li></ul></li></ul></li></ul></li></ul></li><li><p>In order to produce an AST that looks like this, the parser has to know about operator precedences where the precedence of * is higher than +.</p></li><li><p>That&#39;s the most common example for operator precedence, but there are a lot more cases where it&#39;s important.</p></li><li><p>Consider this expression.</p><ul><li>parenthesis ()</li><li>parentheses ()</li></ul></li><li><p>In contrast to this, the let token can only appear once at the beginning of a let statement, which makes it easy to determine what the rest of the statement is supposed to be.</p><ul><li>determine -&gt; make sure</li><li>supposed <ul><li>be supposed to <ul><li>to have to; to have a duty or a responsibility to</li><li>the children are supposed to be at school by 8.45 a.m</li><li>What are you doing out of bed - you&#39;re supposed to be asleep</li><li>You&#39;re not supposed(= allowed) to park here.</li></ul></li><li>used to show that you do not believe that something or someone really is waht many other people consider them boe be <ul><li>a supposed genuis</li><li>The costs of the programme outweight its supposed benefits.</li></ul></li></ul></li></ul></li><li><p>the rest of</p><ul><li>other</li><li>left</li></ul></li><li><p>In the monkey programming language everything besides let and return statments is an expression. These expressions come in different varieties.</p><ul><li>varieties -&gt; kind of?</li><li>beside <ul><li>Those books seem very dull beside this one. <ul><li>dull - boring</li></ul></li></ul></li></ul></li><li><p>infix operators -&gt; binary operators</p></li><li><p>And of course, as we previously saw, we can use parentheses to group expressions and influence the order of evaluation.</p><ul><li>influence - 影响</li><li>enfluence</li></ul></li><li><p>first-class citizens</p></li><li><p>approach</p></li><li><p>Top Down Operator Precedence</p><ul><li>... is very simple to understand, trivial to implement, easy to use, extremely efficent in practice if not in theory, yet flexible enought to meet most reasonable syntacitc needs of users ...</li></ul></li><li><p>I guess that doesn&#39;t make a lot of sense yet. We never saw how to associate parsing functions with grammaer rules, so the idea of using token types instead of these rules doesn&#39;t register as anything realy novel or revelatory. To be completely honest: I was facing a chicken and egg problem when writing this section.</p></li><li><p>Is it better to explain this algorithm in abstract terms and then show the implemetation, possibly causing you to jump back and forth between pages, or to show the implementation with the explanation following, causing your to probably skip over the implementation and not getting a lot out of the explanation?</p></li><li><p>The answer, I decided, is neither of these to options. What we&#39;re going to do instread is strat implementing the expression parsing part of our parser.</p></li><li><p>And before we start writing any code, let&#39;s just be clear on the terminology</p><ul><li>terminology - 术语</li></ul></li><li><p>A prefix operator is an operator &quot;in front of&quot; its operand.</p></li><li><p>This is going to be really handy in tests.</p></li><li><p>It&#39;s important to not that left is our already parsed *ast.IntegerLiteral that represents the 1.</p></li></ul><p><a href="https://dictionary.cambridge.org/zhs/%E8%AF%8D%E5%85%B8/%E8%8B%B1%E8%AF%AD-%E6%B1%89%E8%AF%AD-%E7%B9%81%E4%BD%93/supposed" target="_blank" rel="nofollow noopener noreferrer">https://dictionary.cambridge.org/zhs/%E8%AF%8D%E5%85%B8/%E8%8B%B1%E8%AF%AD-%E6%B1%89%E8%AF%AD-%E7%B9%81%E4%BD%93/supposed</a></p>',2)]))}const g=i(n,[["render",s]]);export{c as __pageData,g as default};
